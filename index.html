<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>comandos git </title>
</head>
<body>
    <h1>Arquitectura de una aplicacion</h1>

    <ul>
        <li>https://roadmap.sh</li>
        <li>--Monolitica</li>
        <li>--Distribuida</li>
        <li>--Hibrida</li>
        <li>--Orientada a servicios (SOA)</li>
        <ul>
            <li>autocontenido (self contained)</li>
            <li>los servicios son  caja negra para el consumidor</li>
            <li>representan una actividad de negocio especifica</li>
        </ul>
        <ul>
            <li>web services --una manera de crear una SOA, no es una arq. SOA</li>
            <li>SOAP (xml) </li>
            <li>RESTFul HTTP</li>
            <li>graphQL</li>
        </ul>

    </ul>
    
    <h1>
        The twelve-factor app -principles
    </h1>
    <ul>
        <li>formas <b>declarativas</b> de configuracion</li>
        <li> <b> contrato claro</b> con OS</li>
        <li>listas para <b>lanzar</b> en cualquier momento</li>
        <li>Minimizar la  <b>diferencia</b> entre entornos de desarrollo </li>
        <li><b>facil de escalar</b></li>


    </ul>

    <ul>
        <li>Codebase (ej. git, una sola fuente)</li>
        <li>Dependencias (se deben definir explicitamente en un solo lugar)</li>
        <li>configuration(ej virtual env, docker)</li>
    </ul>



    
    <h1>GIT</h1>



    <ul>
        <li>git clone https://github.com/grancerbero/hello.git</li>
        <li>git status</li>
        <li>git add hello.html</li>
        <li>git commit -m "add hello.html"</li>
        <li>git config --global user.email "grancerbero@gmail.com"</li>
        <li>git config --global user.name "gran cerbero"</li>
        <li>git push</li>
        <li>git pull</li>
        <li>git config pull.rebase false</li>
        <li>git log</li>
        <li>git branch</li>
        <li>git checkout -b style</li>
        <li>git checkout main</li>
        <li>git checkout style</li>
        <li>git merge style (ubicandose en main)</li>
        <li>git push origin style</li>
    </ul>
    <h1>GIT- i have a  directory in my local computer , and i want this to  github</h1>
    <ul>
        <li> echo "# django" >> README.md</li>
        <li>git init</li>
        <li>git add .</li>
        <li>git add README.md</li>
        <li>git commit -m "first commit"</li>
        <li>git branch -M main</li>
        <li>git remote add origin https://github.com/grancerbero/django.git</li>
        <li>git push -u origin main</li>
    </ul>

    <h1>Python</h1>
    <h2>Instalacion en ubuntu</h2>
    <br>sudo add-apt-repository ppa:deadsnakes/ppa
    <br>sudo apt update
    <br>sudo apt install python3.11
    <br> ls -l /usr/bin/python*
    <br> python3 -V
    <br>python3.11

    <h1>DJANGO</h1>
    <br> sudo apt install python3-pip
    <br>pip3 install Django
    <br>sudo apt install python3-django
    <br> django-admin startproject lecture3
    <br>python3 manage.py runserver (ejecutar runserver)
    <br>python3 manage.py  startapp hello  <em>crea un api</em>
    <br>python3 manage.py  migrate  <em> en Django se utiliza para aplicar las migraciones pendientes a la base de datos. Las migraciones son una forma de gestionar los cambios en la estructura de la base de datos a lo largo del tiempo. Este comando específico realiza las siguientes acciones:</em>

    <br> python3 manage.py createsuperuser <em>for create a superuser</em>
    <br> python3 manage.py startapp users  <em>para crear una api llamada users</em>
    <br> python3 manage.py test <em>Ejecuta pruebas realizadas</em>
    
    <h1>exploring objects in Django</h1>
    <br>   python3 manage.py shell
    <br>from flights.models import *
    <br> flights = Flight.objects.all()


    <br># Importar modelos y bibliotecas necesarias
    <br>from miapp.models import MiModelo, OtroModelo
    <br>from django.db.models import Q
    
    <br># Crear un objeto
    <br>objeto = MiModelo(nombre="Ejemplo", descripcion="Descripción de ejemplo")
    <br>objeto.save()
    
    <br># Consultar objetos
    <br>todos_los_objetos = MiModelo.objects.all()
    <br>objeto_especifico = MiModelo.objects.get(id=1)
    <br>objetos_filtrados = MiModelo.objects.filter(nombre__icontains="ejemplo")
    
    <br># Actualizar un objeto
    <br>objeto = MiModelo.objects.get(id=1)
    <br>objeto.nombre = "Nuevo nombre"
    <br>objeto.save()
    
    <br># Eliminar un objeto
    <br>objeto = MiModelo.objects.get(id=1)
    <br>objeto.delete()
    
    <br># Relaciones entre objetos
    <br>objeto1 = MiModelo.objects.get(id=1)
    <br>objeto2 = OtroModelo.objects.get(id=2)
    <br>objeto1.relacion = objeto2
    <br>objeto1.save()
    
    <br># Consultas avanzadas
    <br>objetos_complejos = MiModelo.objects.filter(Q(nombre__icontains="ejemplo") | Q(descripcion__icontains="ejemplo"))
    
    <br># Operaciones en masa
    <br>MiModelo.objects.update(descripcion="Nueva descripción para todos")
    
    <br># Acceder a campos relacionados
    <br>objeto = MiModelo.objects.get(id=1)
    <br>relacion_objeto = objeto.relacion_modelo  # Reemplaza 'relacion_modelo' con el nombre de tu campo de relación

    <br>Test de serializacion de un objeto1
    <br>hejurado@HJS:~/proyectos/pythoncourse/airline$ python3 manage.py shell
    <br>Python 3.10.12 (main, Nov 20 2023, 15:14:05) [GCC 11.4.0]
    <br>Type 'copyright', 'credits' or 'license' for more information
    <br>IPython 8.20.0 -- An enhanced Interactive Python. Type '?' for help.
    
    <br>In [1]: from flights.models import *
    
    <br>In [2]: from flights.serializers import FlightSerializer
    
    <br>In [3]: flight = Flight.objects.first()
    
    <br>In [4]: flight.duration
    <br>Out[4]: 415
    
    <br>In [5]: flight
    <br>Out[5]: <Flight: 1:New York:JFK  to London:LHR  : state False>
    
    <br>In [6]: serializer = FlightSerializer(flight)
    
    <br>In [7]: serializer
    <br>Out[7]:
    <br>FlightSerializer(<Flight: 1:New York:JFK  to London:LHR  : state False>):
        <br>        origin = AirPortSerializer():
        <br>        code = CharField()
        <br>        city = CharField()
        <br>destination = AirPortSerializer():
        <br>    code = CharField()
        <br>    city = CharField()
        <br>duration = IntegerField()
    
    <br>In [8]: serializer.data
    <br>Out[8]: {'origin': OrderedDict([('code', 'JFK'), ('city', 'New York')]), 'destination': OrderedDict([('code', 'LHR'), ('city', 'London')]), 'duration': 415}
    
    <br>In [9]:



    <hr>
    <h1>JAVASCRIPT</h1>
    <br>querySelector
        <ul>
            <li>document.querySelector ('tag')</li>
            <li>document.querySelector ('#id')</li>
            <li>document.querySelector ('.class')</li>
        </ul>
    <br>Eventos
    <ul>
        <li>onclick</li>
        <li>onmouseover</li>
        <li>onkeydown</li>
        <li>onkeyup</li>
        <li>onload</li>
        <li>onblur</li>
    </ul>


    <br>Local Storage
    <ul>
        <li>localStorage.getItem(key)</li>
        <li>localStorage.setItem(key, value)</li>
        
    </ul>

    
    <h1>REACT</h1>

    <ul>
    <li> React es la biblioteca para construir interfaces de usuario en JavaScript.</li>
    <li> ReactDOM es una biblioteca complementaria específica de React que se utiliza para interactuar con el DOM y renderizar componentes React en la interfaz de usuario.</li>
    <li> Babel es un compilador de JavaScript que se utiliza para transformar código JavaScript moderno y JSX en un formato compatible con los navegadores.</li>
    </ul>

    <h1>LOAD BALANCING METHODS</h1>
    <ul>
        <li>Random choice</li>
        <li>Round robin</li>
        <li>fewest connections</li>
    </ul>

    <h1>SESSION-AWARE LOAD BALANCING </h1>
    <ul>
        <li>Sticky Sessions</li>
        <li>Sessions in database</li>
        <li>Client-Side Sessions</li>
    </ul>

    <h1>AUTOSCALLING</h1>
    <P>El término "autoscaling" en el contexto de un balanceador de cargas se refiere a la capacidad del sistema para ajustar automáticamente la cantidad de recursos (como instancias de servidor) en respuesta a cambios en la carga de trabajo. El autoscaling es una técnica utilizada para garantizar que el sistema pueda manejar eficientemente tanto picos de tráfico como periodos de baja demanda, optimizando así el rendimiento y la utilización de recursos.<BR/>

    Cuando se implementa autoscaling en conjunción con un balanceador de cargas, la idea es aumentar o disminuir dinámicamente la cantidad de instancias de servidor disponibles según sea necesario para manejar la carga actual. Aquí hay algunos conceptos clave asociados con autoscaling y balanceo de cargas:<BR/>
    
    --Escalado automático hacia arriba (Upscaling): Cuando la carga de trabajo aumenta, el sistema puede agregar automáticamente nuevas instancias de servidor para distribuir la carga de manera más equitativa. El balanceador de cargas se encarga de dirigir las solicitudes entrantes a las instancias disponibles.<BR/>
    
    --Escalado automático hacia abajo (Downscaling): Cuando la carga de trabajo disminuye, el sistema puede eliminar instancias de servidor para ahorrar recursos. El balanceador de cargas ajusta dinámicamente sus configuraciones para dirigir las solicitudes solo a las instancias que están activas.<BR/><BR/>
    
    Políticas de escalado: Se definen reglas y políticas para determinar cuándo y cuánto escalar. Estas reglas pueden basarse en métricas como el uso de la CPU, la memoria, la cantidad de solicitudes entrantes, entre otros.<BR/><BR/>
    
    Monitoreo continuo: El sistema de autoscaling monitorea constantemente el rendimiento y la carga del sistema para tomar decisiones informadas sobre cuándo y cómo escalar.<BR/><BR/>
    
    Al implementar autoscaling junto con un balanceador de cargas, se logra una mayor flexibilidad y eficiencia en la gestión de recursos, ya que el sistema puede adaptarse automáticamente a cambios en la demanda de la aplicación sin intervención manual. Esto es especialmente beneficioso en entornos dinámicos donde la carga de trabajo varía a lo largo del tiempo<BR/><BR/>
    </P>

    <h1>SCALING DATABASES</h1>
    <ul>
        <li>Database partition</li>
        <li>Database replication</li>
        <li>

        
            <ul>
                <li>Single-primary replication</li>
                <li>Multi-primary replication</li>
                <li>Caching: cache-control: max-age=86400 | ETag : "7477656E4796569676874" </li>


            </ul>
        </li>
    </ul>

    <h1>DJANGO CACHE FRAMEWORK</h1>
    <ul>
        <li>Per-view caching</li>
        <li>Template  fragment caching</li>
        <li>Low level cache API</li>
    </ul>


    <h1>API Keys</h1>
    <ul>
        <li>Rate limiting</li>
        <li>Route authentication</li>
    </ul>

    <h1>Cross-Site Scripting</h1>
    <ul>
        <li>"Cross-Site Scripting" (XSS) es una vulnerabilidad de seguridad que afecta a las aplicaciones web. Se produce cuando un atacante logra inyectar scripts maliciosos (código JavaScript, por lo general) en páginas web vistas por otros usuarios. El atacante utiliza la confianza que un sitio web tiene en el usuario para ejecutar scripts en su navegador web.</li>
        <li></li>
    </ul>

    <h1>Librerias utiles</h1>
    <ul>
    <li>httpie</li>
    <li>C:\Program Files\PostgreSQL\16\scripts>psql -U postgres -d postgres -a -f dump.sql   <em>importar base de datos que esta exportada como sql plain</em></li>
    </ul>

    <h1>python</h1>
    <ul>
        <li>Abre una terminal en tu distribución de Linux.</li>
        <li>Asegúrate de tener Python y pip instalados en tu sistema. Puedes verificarlo ejecutando los siguientes comandos:
          <ul>
            <li><code>python --version</code></li>
            <li><code>pip --version</code></li>
          </ul>
        </li>
        <li>Si no tienes Python instalado, puedes instalarlo desde el gestor de paquetes de tu distribución. Por ejemplo, en Ubuntu puedes ejecutar:
          <ul>
            <li><code>sudo apt update</code></li>
            <li><code>sudo apt install python3 python3-pip</code></li>
          </ul>
        </li>
        <li>Una vez que tengas Python y pip instalados, puedes instalar JupyterLab ejecutando el siguiente comando:
          <ul>
            <li><code>pip install jupyterlab</code></li>
          </ul>
        </li>
        <li>Este comando instalará JupyterLab y todas las dependencias necesarias en tu sistema.</li>
        <li>Después de la instalación, puedes iniciar JupyterLab ejecutando el siguiente comando en la terminal:
          <ul>
            <li><code>jupyter lab</code></li>
          </ul>
        </li>
        <li>Visual Python is an extension to Jupyter Lab, so you must have Jupyter Lab installed already.
            <br>Python version 3.x
            <br>Jupyter lab environment
            <br>pip install jupyterlab-visualpython
        </li>
        

      </ul>



</body>
</html>